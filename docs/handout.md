# 数字IC培训讲义

::: info
文章修修补补中，有问题可以私信或者群里告诉我（欢迎来实验室线下真实我）
:::

---

## 前言

本讲义内容广泛，但各部分较为简明，旨在帮助你快速掌握嵌入式开发、计算机和数字电路等领域的基础知识。通过下图，你可以直观地了解讲义所涉及的主要内容。
![2024-10-19T15:25:51.png][1]
在学习过程中，我们将使用鸭蛋FPGA开发平台，运行基于RISC-V架构的Yadan CPU，模拟单片机环境。你将使用C语言或Arduino编写程序，控制开发板上的LED灯，并最终设计数字电路，实现对LED灯的控制。

<br>在每次集中培训前，你需要提前完成相应的预学习任务。同时，我们鼓励你根据讲义提前完成培训的所有内容。

---
## 预学习一

### 内容
- 你缺失的那门计算机课——Windows的基本使用
- 复习 C 语言

### 预计时间
You tell me.

### 具体内容
- 查看[你缺失的那门计算机课][2]网站，学习基础篇和软件篇并完成练习。
- 自行寻找教程复习 C 语言语法。

### 验收标准
无

---

## 鸭蛋开发板开发环境配置

### 预计时间
1h

### 具体内容
- 查看[鸭蛋文档][3]，完成第三章。

### 注意事项
- 务必使用 [TD5.6.2][4] 版本
- 将 license 文件放到 `C:\Anlogic\TD5.6.2\license`
- Arduino IDE 使用 [2.3.3][5] 版本
- 在 Arduino 开发板管理器中下载 Yadan 的开发环境时，会遇到报错，自行 STFW（Search The Fucking Web）
- RISC-V GCC 工具链使用 [v10.1.0-1.1][6] 版本

### 验收标准
无

---

## 程序是如何从C语言编译成计算机可以理解的指令？

如果你想进一步了解这方面的内容，可以阅读[《深入理解计算机系统》][7]。

C语言是一种编译型语言，它需要通过编译器将源代码转换为可执行的机器代码。编译过程通常分为以下几个阶段：

1. **预处理（Preprocessing）**：
   - 处理所有预处理指令，如`##include`、`##define`、以及条件编译指令等。
   - 输出是一个经过预处理的C源文件。

2. **编译（Compilation）**：
   - 将预处理后的C代码转换为汇编代码。这一步主要是进行语法分析、语义分析和优化。
   - 输出是对应平台的汇编代码文件。

3. **汇编（Assembly）**：
   - 将汇编代码转换为目标机器代码（机器指令）。
   - 输出是目标文件（object file），通常是二进制格式的。

4. **链接（Linking）**：
   - 将多个目标文件和库文件结合在一起，形成一个可执行文件。
   - 处理外部符号引用，并将函数和变量地址进行必要的调整。

编译器（如GCC、Clang等）通过这几个阶段将C源代码转换为最终可以在目标平台运行的可执行程序。这个过程涉及语法和语义检查、代码优化等多种复杂技术。

在使用`gcc`时，你可以分步骤进行编译。以下是每个步骤的命令：

1. **预处理**：
   ```bash
   gcc -E source_file.c -o preprocessed_file.i
   ```

2. **编译（生成汇编代码）**：
   ```bash
   gcc -S preprocessed_file.i -o assembly_file.s
   ```

3. **汇编（生成目标文件）**：
   ```bash
   gcc -c assembly_file.s -o object_file.o
   ```

4. **链接（生成可执行文件）**：
   ```bash
   gcc object_file.o -o executable_name
   ```

通过这些步骤，可以手动控制编译过程中的每个阶段，并检查各阶段的中间输出。

### 链接

<br>C语言编程的核心能力之一就是链接OS所提供的库。链接是一种为你的程序添加额外特性的方法，这些特性由其它人在系统中创建并打包。
<br>C中的库有两种基本类型：
<br>**静态**:
<br>你可以使用ar和ranlib来构建它，就像上个练习中的libYOUR_LIBRARY.a那样（Windows下后缀为.lib）。这种库可以当做一系列.o对象文件和函数的容器，以及当你构建程序时，可以当做是一个大型的.o文件。
<br>**动态** :
<br>它们通常以.so（Linux）或.dll（Windows）结尾。这些文件都被构建好并且放置到指定的地方。当你运行程序时，OS会动态加载这些文件并且“凭空”链接到你的程序中。

#### 静态库

##### 构建静态库

1. **编写源文件**：创建一个或多个C源文件和相应的头文件。例如，你可以有 `foo.c` 和 `foo.h`。

   ```c
   /* foo.h */
   ##ifndef FOO_H
   ##define FOO_H

   void hello();

   ##endif
   ```

   ```c
   /* foo.c */
   ##include <stdio.h>
   ##include "foo.h"

   void hello() {
       printf("Hello, World!\n");
   }
   ```

2. **编译源文件为目标文件**：使用 `gcc` 或其他C编译器将源文件编译成目标文件（.o 文件）。

   ```bash
   gcc -c foo.c -o foo.o
   ```

   这条命令会生成一个名为 `foo.o` 的目标文件。

3. **创建静态库文件**：使用 `ar` 命令创建一个静态库文件（.a 文件）。

   ```bash
   ar rcs libfoo.a foo.o
   ```

   这条命令会把 `foo.o` 打包成一个名为 `libfoo.a` 的静态库。

##### 链接静态库

4. **编写使用库的程序**：创建一个C程序使用你生成的库。

   ```c
   /* main.c */
   ##include "foo.h"

   int main() {
       hello();
       return 0;
   }
   ```

5. **编译并链接程序**：编译使用静态库的程序，同时链接静态库。

   ```bash
   gcc main.c -L. -lfoo -o main
   ```

   这里的 `-L.` 指定库路径为当前目录，`-lfoo` 表示链接名为 `libfoo.a` 的库（`lib` 和 `.a` 是默认前缀和后缀，所以只需指定 `foo`）。

6. **运行程序**：编译成功后，直接运行生成的可执行文件 `main`。

   ```bash
   ./main
   ```

   输出应该是：

   ```
   Hello, World!
   ```
创建一个动态库（又称共享库）在 C 语言中涉及以下步骤。我们以 Linux 系统为例，使用 `gcc` 编译器来创建和使用动态库。

#### 动态库

##### 创建动态库

1. **编写源文件**：与创建静态库类似，你需要编写源文件和头文件。例如，使用 `foo.c` 和 `foo.h`：

   ```c
   /* foo.h */
   ##ifndef FOO_H
   ##define FOO_H

   void hello();

   ##endif
   ```

   ```c
   /* foo.c */
   ##include <stdio.h>
   ##include "foo.h"

   void hello() {
       printf("Hello, Dynamic World!\n");
   }
   ```

2. **编译源文件为目标文件**：编译时使用 `-fPIC` 选项生成位置无关代码，这对于动态库很重要。

   ```bash
   gcc -c foo.c -fPIC -o foo.o
   ```

3. **创建共享库文件**：使用 `-shared` 选项生成动态库（.so 文件）。

   ```bash
   gcc -shared -o libfoo.so foo.o
   ```

   这将创建一个名为 `libfoo.so` 的共享库。

##### 链接和使用动态库

4. **编写使用库的程序**：创建一个程序来使用共享库。

   ```c
   /* main.c */
   ##include "foo.h"

   int main() {
       hello();
       return 0;
   }
   ```

5. **编译并链接程序**：编译使用动态库的程序，指定库路径和库名称。

   ```bash
   gcc main.c -L. -lfoo -o main
   ```

   命令说明：
   - `-L.` 指定库路径为当前目录。
   - `-lfoo` 指定要链接的库为 `libfoo.so`（`lib` 和 `.so` 是约定前缀和后缀）。

6. **运行程序**：为了让程序找到并加载共享库，你可以：

   - 设置 `LD_LIBRARY_PATH` 环境变量，或者，
   - 将共享库复制到系统库路径下，例如 `/usr/lib` 或 `/usr/local/lib`。

   使用 `LD_LIBRARY_PATH`，可以运行：

   ```bash
   export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:.
   ./main
   ```

   运行后，输出应该是：

   ```
   Hello, Dynamic World!
   ```

---

## 使用鸭蛋的基本姿势

### 预计时间
1.5h

### 具体内容
- 查看[鸭蛋文档第四章][8]，完成第四章。

### 注意事项
- 使用 Yadan SOC，你需要下载Yadan SOC的[工程文件][9]，自行使用TD生成比特流文件并且烧录。
- 自行 STFW，安装 Python 环境
- 在 4.3.2 编写代码中，你的代码需要在[样例空工程][10]中进行编写
- 鸭蛋文档中的4.3.5, 4.3.6不需要阅读

### 验收标准
- 分别使用 Arduino IDE 和 C 语言从底层点亮 LED 灯

---

## UART串口，PWM，GPIO
### UART
<br>通信方式在日常的应用中一般分为串行通信（serial communication）和并行通信（parallel communication）。**UART使用的是串行通信**。首先我们了解下什么是并行通信，并行通信是指多比特数据同时通过并行线进行传送，一般以字或字节为单位并行进行传输。这种传输方式用的通信线多、成本高。
<br>我们再来了解下串行通信的特点。串行通信是指数据在一条数据线上，一比特接一比特地按顺序传送的方式，这一点与并行通信是不同的。这里我们以传输一个字节（8位）数据为例，在并行通信中，一个字节的数据是在 8 条并行传输线上同时由源地传送到目的地；而在串行通信中，因为数据是在一条传输线上一位接一位地顺序传送的，所以一个字节的数据要分8次进行传送。如果我们以T为一个时间单位的话，那么并行通信发送一个字节的数据只需要1T的时间，而串行通信需要8T的时间，由此可以总结出串行通信的的特点：一是节省传输线，大大降低了使用成本，二是数据传送速度慢，这一点在大位宽的数据传输上尤为明显。综上可知，串行通信主要应用于长距离、低速率的通信场合。
#### 接口定义
UART的接线很简单，只需要连接两根线就可以发送数据
![2024-10-26T10:21:45.png][11]
#### 数据格式
<br>**起始位**：当不传输数据时，UART数据传输线通常保持高电压电平。若要开始数据传输，发送UART会将传输线从高电平拉到低电平并保持1个波特率周期。当接收UART检测到高到低电压跃迁时，便开始以波特率对应的频率读取数据帧中的位。 
<br>**数据帧**：数据帧包含所传输的实际数据。如果使用奇偶校验位，数据帧长度可以是5位到8位。如果不使用奇偶校验位，数据帧长度可以是9位。在大多数情况下，数据以最低有效位优先方式发送。 
<br>**奇偶校验**：奇偶性描述数字是偶数还是奇数。通过奇偶校验位，接收 UART 判断传输期间是否有数据发生改变。电磁辐射、不一致的波特率或长距离数据传输都可能改变数据位。接收 UART读取数据帧后，将计数值为1的位，检查总数是偶数还是奇数。如果奇偶校验位为0（偶数奇偶校验），则数据帧中的1或逻辑高位总计应为偶数。如果奇偶校验位为1（奇数奇偶校验），则数据帧中的1或逻辑高位总计应为奇数。当奇偶校验位与数据匹配时，UART认为传输未出错。但是，如果奇偶校验位为0，而总和为奇数，或者奇偶校验位为1，而总和为偶数，则UART认为数据帧中的位已改变。 
<br>**停止位**：为了表示数据包结束，发送UART将数据传输线从低电压驱动到高电压并保持1到2位时间。 
![2024-10-26T10:24:40.png][12]
#### 奇偶检验
你可以阅读我的[文章][13]，详细了解如何通过奇偶检验来纠正数据传输中的错误。
#### 波特率
即每秒传输的位数(bit)。一般选波特率都会有9600，19200，115200等选项。其实就是每秒传输这么多个比特位数(bit)。两个设备需要约定好相同的波特率才能进行通讯。

### GPIO
GPIO（General Purpose Input/Output，通用输入/输出）是微控制器和其他集成电路上的一种通用引脚，用于实现数字信号的输入和输出。
#### 功能
<br>输入模式：用于读取外部设备的数字信号。例如，按钮状态。
<br>输出模式：用于向外部设备发送数字信号。例如，控制LED亮灭。
#### 例子
在Arduino中，使用pinMode()函数配置引脚为输入或输出；使用digitalWrite()和digitalRead()分别操作输出和读取输入。
### PWM
<br>用于模拟信号控制的数字信号技术。通过调节脉冲信号的占空比，可以模拟输出连续的模拟电压。
<br>下图是一个50%占空比的PWM波，假设他的高电压的时候是5V，那么50%占空比就可以等效成5V*50%=2.5V。
![2024-10-26T11:56:08.png][14]
<br>通过PWM，我们可以简单的调整LED灯的亮度，电机的转速等。

---

## 使用 Arduino 花式点亮 LED 灯

你将会用到 UART、PWM、GPIO 的知识。

### 预计时间
4h

### 具体内容
- 完成[鸭蛋文档第五章实验一][15]

### 注意事项
- 你可能需要使用到GPIO引脚，查看鸭蛋文档1.1获取相关信息
- yadan的Arduino可能无法使用analogWrite()函数输出PWM波，如果你需要输出PWM波，你可以自己写一个PWM的函数，通过不断调整GPIO口的电压的高低达到PWM的效果。

### 验收标准
- YADAN Board 能通过 UART 串口接收 PC 发送来的参数以调整灯闪烁的间隔时间。

---

## 最简单的CPU是怎样工作的？

本章内容参考自南京大学计算机系统基础实验[1.2][16],[2.1][17]，以及CS61-C。<br>

在我们日常使用的计算设备中，电脑的架构可以分为软件和硬件两大部分。在最上层，我们看到的是软件，例如大家常用的微信、浏览器等应用。这些应用软件运行在操作系统上，操作系统为它们提供了一个统一的运行环境。而对于一些简单的设备，如51单片机，它们可以直接运行C语言编译成的机器代码，无需操作系统的参与。

值得一提的是，一些更高级的单片机（如STM32）允许在其上运行操作系统(RTOS等)，以便进行更复杂的处理。
![计算机结构图](/images/handout/计算机结构图.png)

图片中，与操作系统并列的有编译器和汇编器。编译器能够将C语言等高级语言转化为汇编语言，而汇编器则负责将汇编语言转换为机器指令，这些指令是二进制格式的，计算机硬件能够直接识别与执行。

在硬件部分，我们看到主要的组成包括处理器和内存。处理器负责执行计算任务，而内存用于暂时存放运行中的数据和指令。其中，输入输出设备（如硬盘和键盘）也属于硬件范畴。更底层的则是数字电路和模拟电路。

软件和硬件之间的桥梁是指令集架构（ISA）。ISA是一套人为定义的标准，规定了CPU的指令操作，指导我们开发相应的汇编器、编译器和操作系统。同时，硬件设计需要遵循ISA中定义的指令集。目前，常见的ISA包括x86和ARM。大多数个人计算机采用x86架构，而苹果Mac电脑和大多数智能手机使用的是ARM架构。

### 计算机科学中的抽象

计算机科学中最重要的概念之一是抽象。抽象使得复杂性管理变得可行，允许我们开发跨平台的软件。以浏览器为例，它有超过90,000个文件，超过500万行代码，却能运行在多个操作系统上。如果没有抽象，每种硬件和操作系统可能都需要独立的软件版本，增加无限复杂性。
![浏览器代码量](/images/handout/浏览器代码量.png)![浏览器运行平台](/images/handout/浏览器运行平台.png)
通过抽象，开发者仅需使用如C语言等高级语言编写代码，而无需针对不同硬件的底层电路或汇编代码进行定制。汇编器和编译器仅关注指令集的翻译和优化，而不受具体硬件设计的限制。
![抽象层级](/images/handout/抽象层级.png)
### 程序如何在CPU上执行

接下来，我们探讨程序如何在CPU上执行。程序在编译后会生成一组指令，这些指令存储在磁盘上。当程序运行时，指令被载入内存，准备执行。CPU通过程序计数器（PC）找到内存中的下一条指令。PC初始化到一个预设值，每次取指后，它会递增，指向下一条指令。
![cpu结构图](/images/handout/cpu结构图.png)![内存模型](/images/handout/内存模型.png)
考虑一个加法运算指令：`c = a + b`，完成后c的值可能用于后续运算。为了提高性能，c可以存储在CPU的寄存器中，而非内存。寄存器是高速缓存数据的硬件单元，大大提高了计算速度。

指令处理一般分为四个阶段不断循环：取指、译码、执行及更新PC。每一阶段都有独特的作用，取指从内存获取指令，译码解析指令含义和所需的CPU单元（如ALU用于算术运算），执行具体落实指令功能，更新PC则设定下一步要处理的指令地址。

下图有两个函数，当我们需要调用任意一个函数时，需要使用跳转指令去改变pc的值，从而跳到要调用的函数的内存地址上去。如果没有遇到跳转指令，那么pc就会默认+1,顺序执行下一条指令。

![pc函数跳转](/images/handout/pc函数跳转.png)

::: info
自行阅读并理解[YEMU模拟器](https://ysyx.oscc.cc/docs/ics-pa/2.1.html#yemu-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84cpu%E6%A8%A1%E6%8B%9F%E5%99%A8)
:::

---

## 使用 C 语言点亮 LED 灯

你需要学习配置定时器寄存器并点亮 LED 灯。

### 预计时间
1h

### 具体内容
- 完成[鸭蛋文档第五章实验二][18]

### 验收标准
- 自己配置寄存器并使 LED 灯闪烁

---

## 函数库设计

自己为定时器编写库函数，功能自定。比如写一个：

```c
void Timer_cmp_set(); //设置指定定时器的compare值
void Timer_PRE_set(); //设置指定定时器的预分频值
void Timer_en_set(); // 启用指定定时器
void Timer_value_set(); // 设置指定定时器的值
unsigned int Timer_value_read(); //读取指定定时器的值
```

### 预计时间
1h

### 验收标准
- 看你代码以及运行效果

---

::: info
你已经学习了嵌入式的部分内容，现在可以尝试使用 51 单片机或鸭蛋制作一个小作品。
:::

---

## 进阶一（可选）

### 内容
自由设计

### 预计时间
You tell me.

### 具体内容
自由设计你的作品，比如智能（障）小车、温湿度计、指纹门锁。以下为可选参考：
- 温湿度显示系统
  > 使用 DHT11 温湿度传感器采集温湿度信息，通过 UART 串口发送到 PC 机显示。
  > DHT11 是一款单总线通信的温湿度传感器，仅需一个上拉的 GPIO 端口就可以实现数据传输。完成此设计需要了解 DHT11 的通信方式，并编写相应库函数，实现对 DHT11 的驱动。

- 宿舍智能门锁
  > 使用外接蓝牙模块或者指纹模块，控制舵机转动从而拉动宿舍门锁实现开门。（真的能开门！）
  > 蓝牙模块或指纹模块均使用UART串口与开发板通讯，舵机通过开发板的PWM信号控制转动的角度。

### 验收标准
无

---

## 预学习二

### 内容
学习数电与 Verilog

### 预计时间
You tell me.

### 具体内容
- 阅读[《数字设计和计算机体系结构》][19]第一到四章，学习数电知识和 Verilog 语言
- 使用 USTC 的[Verilog OJ][20]练习 Verilog，根据自己情况选择完成，若有基础，可以直接挑选靠后的题目。
- 【从电路设计的角度入门VerilogHDL】 https://www.bilibili.com/video/BV1PS4y1s7XW

### 验收标准
- USTC OJ 完成题目至 ID60（根据自己情况适当跳过前面题目）

---

## FPGA 点亮 LED 灯

### 预计时间
4h

### 具体内容
- 查看[文档][21]并完成。

### 验收标准
- 使用 FPGA 成功点亮 LED 灯

---

## FPGA 使用 PWM 点亮 LED 灯

### 预计时间
4h

### 具体内容
- 查看[文档][22]并完成。

### 验收标准
- FPGA 使用 PWM 成功点亮 LED 灯

---

## FPGA 使用旋钮调节灯的亮度

### 预计时间
4h

### 具体内容
- 查看[文档][23]并完成。

### 验收标准
- FPGA 使用 PWM 成功点亮 LED 灯

---

## FPGA 使用 UART 串口实现与电脑通讯

### 预计时间
4h

### 具体内容
- 查看[文档][24]并完成。

::: info
你已经学会了如何使用 FPGA 开发，现在可以尝试参加集创赛的数字设计赛道以及 FPGA 应用赛道。
:::

### 验收标准
- 从电脑接收或发送数据，并点亮 LED 灯

---

## 进阶二（可选）

### 内容
一生一芯

### 预计时间
**∞**

### 具体内容
- 一生一芯项目[主页][25]

---

## 进阶二的小帮助
如何使用 sing-box 加速 GitHub 的访问

::: warning
没法说没法说
:::

---


  [1]: https://200502.xyz/usr/uploads/2024/10/2764013689.png##vwid=308&vhei=485
  [2]: https://www.criwits.top/missing/afterwords.html
  [3]: https://docs.yadanboard.com/zh-cn/latest/chap3.html##tangdynasty
  [4]: https://pan.200502.xyz/d/onedrive/%E5%A4%A7%E5%AD%A6/%E9%B8%AD%E8%9B%8B%E8%B5%84%E6%96%99/TD_RELEASE_March2023_r5.6.2_71036_64bit.msi?sign=t8j-neyq_q0OVD9WhKCOWKdYHZqvk0D3YjZPBl1AHBM=:0
  [5]: https://www.arduino.cc/en/software
  [6]: https://pan.200502.xyz/d/local/xpack-riscv-none-embed-gcc-10.1.0-1.1-win32-x64.zip?sign=GiW-eVIcvNFVrfsRCKfhbG5S5AGGlviN9EetWyzPgeY=:0
  [7]: https://pan.200502.xyz/d/local/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.pdf?sign=u4KBWOOWtkjbkgfXuHS4j4q7n29_XxY55k_eWJLGgU0=:0
  [8]: https://docs.yadanboard.com/zh-cn/latest/chap4.html##
  [9]: https://gitee.com/verimake/yadansoc/
  [10]: https://pan.200502.xyz/d/onedrive/%E5%A4%A7%E5%AD%A6/%E9%B8%AD%E8%9B%8B%E8%B5%84%E6%96%99/DemoProject_YADAN_with_download_program.zip?sign=5E_wj-BhPabuDWLyQ4S7y-H6gaqZ4V0v43om3Hv07Sk=:0
  [11]: https://200502.xyz/usr/uploads/2024/10/3128512590.png##vwid=732&vhei=177
  [12]: https://200502.xyz/usr/uploads/2024/10/2873905697.png##vwid=838&vhei=277
  [13]: https://200502.xyz/index.php/archives/236/
  [14]: https://200502.xyz/usr/uploads/2024/10/2827537704.png##vwid=1047&vhei=786
  [15]: https://docs.yadanboard.com/zh-cn/latest/chap5.html##arduino-ide-yadan-board
  [16]: https://ysyx.oscc.cc/docs/ics-pa/1.2.html
  [17]: https://ysyx.oscc.cc/docs/ics-pa/2.1.html
  [18]: https://docs.yadanboard.com/zh-cn/latest/chap5.html##risc-v-gcc
  [19]: https://pan.200502.xyz/d/local/%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.pdf?sign=riFPmgiOKk1leujtYb8VHTTnWimIBWTpuubEm4isRLk=:0
  [20]: https://verilogoj.ustc.edu.cn/oj/
  [21]: https://verimake.com/d/80-yadan-board-verilog-1
  [22]: https://verimake.com/d/115-yadan-board-verilog-2-pwm
  [23]: https://verimake.com/d/146-yadan-board-verilog-3-ip-core-adc
  [24]: https://verimake.com/d/149-yadan-board-verilog-4-uart
  [25]: https://ysyx.oscc.cc/